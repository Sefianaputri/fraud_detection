# -*- coding: utf-8 -*-
"""app_fraud_streamlit.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E2TWw4AKNYFUcnLjT-8ToDgvV1NDaX8u
"""

# Install dulu jika belum
!pip install streamlit

import streamlit as st
import pandas as pd
import numpy as np
import joblib
from datetime import datetime
import os # Import os module to check file existence and size

# --- Load Model ---
model_file_path = "/content/fraud_detection_models.pkl"

# Add checks for file existence and size (optional, helps diagnose but doesn't fix corrupt file)
if not os.path.exists(model_file_path):
    st.error(f"Error: Model file not found at {model_file_path}. Please ensure the file exists.")
    st.stop() # Stop execution if file is not found

# You could also add a size check if you know the expected size, but this is less robust.
# Example:
# expected_size = 262144 # Based on the error message, this might be the expected array data size, not the total file size.
# current_size = os.path.getsize(model_file_path)
# if current_size < some_minimum_expected_size:
#     st.warning(f"Warning: Model file size ({current_size} bytes) seems unusually small. It might be corrupted or incomplete.")


try:
    model_bundle = joblib.load(model_file_path)
    scaler = model_bundle['scaler']
    rf_model = model_bundle['random_forest']
    nb_model = model_bundle['naive_bayes']
    feature_columns = model_bundle['feature_columns']
except Exception as e:
    st.error(f"Error loading the model file. Please check if '{model_file_path}' is a valid and complete joblib file. Details: {e}")
    st.stop() # Stop execution if model loading fails


# --- Streamlit UI ---
st.set_page_config(page_title="Fraud Detection", layout="wide")
st.title("Fraud Detection")

st.subheader("Masukkan Informasi Transaksi")

# --- Input Fields ---
age = st.number_input("Umur", min_value=0, max_value=100, value=30)
sex = st.selectbox("Jenis Kelamin", ["M", "F"])
source = st.selectbox("Sumber Traffic", ["SEO", "Ads", "Direct"])
browser = st.selectbox("Browser", ["Chrome", "Safari", "Firefox", "IE"])
device_id = st.text_input("Device ID")
purchase_value = st.number_input("Nilai Pembelian ($)", min_value=0.0, value=50.0)
signup_time = st.time_input("Waktu Signup")
purchase_time = st.time_input("Waktu Pembelian")

if st.button("🔍 Prediksi"):
    # --- Feature Engineering ---
    # Ensure signup_time and purchase_time are not None before combining
    if signup_time is None or purchase_time is None:
        st.warning("Please enter both signup time and purchase time.")
        st.stop() # Stop if times are not entered

    signup_dt = datetime.combine(datetime.today().date(), signup_time) # Use .date() to avoid potential timezone issues
    purchase_dt = datetime.combine(datetime.today().date(), purchase_time)

    # Handle case where purchase time is before signup time on the same day
    # This might indicate a timing issue or an invalid input
    if purchase_dt < signup_dt:
        st.warning("Purchase time is before signup time. Assuming purchase happened on the next day for calculation.")
        purchase_dt = purchase_dt + pd.Timedelta(days=1)


    time_diff = (purchase_dt - signup_dt).total_seconds()
    signup_hour = signup_dt.hour
    purchase_hour = purchase_dt.hour
    purchase_dayofweek = purchase_dt.weekday() # Use purchase_dt for consistency
    signup_to_purchase_hour = time_diff / 3600
    value_per_age = purchase_value / (age + 1) if age is not None and age >= 0 else purchase_value # Handle division by zero if age is -1 or None
    device_freq = 100 if device_id is not None and device_id.lower() == "frequent" else 1 # Handle None device_id
    device_freq_flag = 1 if device_freq > 50 else 0

    # --- Manual One-Hot Encoding ---
    input_dict = {
        'age': age,
        'purchase_value': purchase_value,
        'signup_hour': signup_hour,
        'purchase_hour': purchase_hour,
        'purchase_dayofweek': purchase_dayofweek,
        'time_diff': time_diff,
        'signup_to_purchase_hour': signup_to_purchase_hour,
        'value_per_age': value_per_age,
        'device_freq': device_freq,
        'device_freq_flag': device_freq_flag,
        # Initialize categorical features to 0 first
        'sex_F': 0, 'sex_M': 0,
        'source_Ads': 0, 'source_Direct': 0, 'source_SEO': 0,
        'browser_Chrome': 0, 'browser_Firefox': 0, 'browser_IE': 0, 'browser_Safari': 0
    }

    # Set the selected categorical feature to 1
    input_dict[f'sex_{sex}'] = 1
    input_dict[f'source_{source}'] = 1
    input_dict[f'browser_{browser}'] = 1


    # --- Pastikan Semua Fitur Terpenuhi ---
    ordered_input_dict = {col: input_dict.get(col, 0) for col in feature_columns}


    input_df = pd.DataFrame([ordered_input_dict])

    # --- Scaling ---
    # Ensure the input DataFrame columns match the scaler's expected columns
    # This is already handled by reordering input_dict
    input_scaled = scaler.transform(input_df[feature_columns])

    # --- Predict ---
    rf_pred = rf_model.predict(input_scaled)[0]
    nb_pred = nb_model.predict(input_scaled)[0]

    # --- Output ---
    st.markdown("---")
    st.success(f" Random Forest Prediction: {'FRAUD' if rf_pred == 1 else 'Aman'}")
    st.success(f" Naive Bayes Prediction: {'FRAUD' if nb_pred == 1 else 'Aman'}")